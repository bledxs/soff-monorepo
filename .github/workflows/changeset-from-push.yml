name: Changeset from Direct Push

on:
  push:
    branches: [master]
    paths:
      - 'packages/**'

jobs:
  create-changeset:
    # Skip if commit is from bot (to avoid loops)
    if: |
      !contains(github.event.head_commit.author.name, 'github-actions') &&
      !contains(github.event.head_commit.message, 'chore: add changeset') &&
      !contains(github.event.head_commit.message, 'chore: version packages')
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Setup Node.js
        uses: actions/setup-node@v6
        with:
          node-version: 20

      - name: Check if changeset already exists for this commit
        id: check
        run: |
          # Check if any changeset was added in this commit
          CHANGESET_ADDED=$(git diff --name-only HEAD~1 HEAD | grep "^\.changeset/.*\.md$" | grep -v "README.md" || true)
          if [ -n "$CHANGESET_ADDED" ]; then
            echo "skip=true" >> $GITHUB_OUTPUT
            echo "Changeset already exists in this commit"
          else
            echo "skip=false" >> $GITHUB_OUTPUT
          fi

      - name: Determine version bump from commit message
        if: steps.check.outputs.skip != 'true'
        id: bump
        run: |
          MESSAGE="${{ github.event.head_commit.message }}"
          # Get first line only
          TITLE=$(echo "$MESSAGE" | head -n 1)

          # Check for breaking change indicator
          if [[ "$TITLE" == *"!"* ]] || [[ "$TITLE" == *"BREAKING"* ]]; then
            echo "type=major" >> $GITHUB_OUTPUT
          elif [[ "$TITLE" =~ ^feat ]]; then
            echo "type=minor" >> $GITHUB_OUTPUT
          elif [[ "$TITLE" =~ ^(fix|perf|refactor|style|docs|test|chore|ci|build) ]]; then
            echo "type=patch" >> $GITHUB_OUTPUT
          else
            echo "type=patch" >> $GITHUB_OUTPUT
          fi

          # Extract description (remove conventional commit prefix)
          DESC=$(echo "$TITLE" | sed -E 's/^(feat|fix|perf|refactor|style|docs|test|chore|ci|build)(\([^)]*\))?!?:\s*//')
          echo "description=$DESC" >> $GITHUB_OUTPUT

      - name: Determine affected packages from changed files
        if: steps.check.outputs.skip != 'true'
        id: packages
        run: |
          PACKAGES=""

          # Get changed files in this commit
          CHANGED_FILES=$(git diff --name-only HEAD~1 HEAD)

          # Extract unique package directories from changed files
          # We filter for files that are inside a subdirectory of packages/
          CHANGED_DIRS=$(echo "$CHANGED_FILES" | grep "^packages/[^/]*/" | cut -d/ -f2 | sort | uniq)

          for dir in $CHANGED_DIRS; do
            PACKAGE_JSON="packages/$dir/package.json"
            if [ -f "$PACKAGE_JSON" ]; then
              # Extract package name using node to be safe with JSON parsing
              PKG_NAME=$(node -p "try { require('./$PACKAGE_JSON').name } catch(e) { '' }")
              
              if [ -n "$PKG_NAME" ]; then
                PACKAGES="$PACKAGES $PKG_NAME"
              fi
            fi
          done

          # Trim leading space
          PACKAGES=$(echo $PACKAGES | xargs)

          echo "list=$PACKAGES" >> $GITHUB_OUTPUT
          echo "Affected packages: $PACKAGES"

      - name: Create changeset file
        if: steps.check.outputs.skip != 'true' && steps.packages.outputs.list != ''
        id: changeset
        run: |
          PACKAGES="${{ steps.packages.outputs.list }}"
          TYPE="${{ steps.bump.outputs.type }}"
          DESC="${{ steps.bump.outputs.description }}"
          SHORT_SHA="${{ github.sha }}"
          SHORT_SHA=${SHORT_SHA:0:7}

          # Generate unique filename
          FILENAME=".changeset/push-${SHORT_SHA}-$(date +%s).md"

          # Create changeset content
          echo "---" > "$FILENAME"
          for pkg in $PACKAGES; do
            echo "\"$pkg\": $TYPE" >> "$FILENAME"
          done
          echo "---" >> "$FILENAME"
          echo "" >> "$FILENAME"
          echo "$DESC" >> "$FILENAME"

          echo "Created changeset:"
          cat "$FILENAME"

          echo "filename=$FILENAME" >> $GITHUB_OUTPUT
          echo "short_sha=$SHORT_SHA" >> $GITHUB_OUTPUT

      - name: Create Pull Request with changeset
        if: steps.check.outputs.skip != 'true' && steps.packages.outputs.list != ''
        uses: peter-evans/create-pull-request@v8
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: 'chore: add changeset for ${{ steps.changeset.outputs.short_sha }}'
          title: 'chore: add changeset for ${{ steps.changeset.outputs.short_sha }}'
          body: |
            This PR adds a changeset for commit ${{ github.sha }}.

            **Affected packages:** ${{ steps.packages.outputs.list }}
            **Bump type:** ${{ steps.bump.outputs.type }}

            Auto-generated by changeset-from-push workflow.
          branch: changeset/${{ steps.changeset.outputs.short_sha }}
          delete-branch: true
          labels: changeset, automated
